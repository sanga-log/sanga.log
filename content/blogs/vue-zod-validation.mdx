---
title: "Vue + Zod로 폼 유효성 검사 개선하기"
excerpt: "기획 변경이 반복될수록 손대기 무서워지는 정규표현식 뭉치. 관리 가능한 구조로 바꾸기 위해 Zod를 도입한 과정을 기록했다."
date: "2025-03-27"
category: "Vue"
tags: ["Vue", "Zod", "TypeScript", "Form Validation"]
---

## 문제의 시작

프로젝트 문의 폼에는 골프장명, 이름, 성, 연락처, 이메일 같은 필드들이 있었습니다. 처음에는 각 필드에 정규표현식을 직접 작성해서 검사했습니다. 필드가 몇 개 없을 때는 이게 딱 맞는 방법처럼 느껴졌습니다.

그런데 기획 변경이 반복되면서 필드가 추가되고 조건이 달라졌습니다. 그 과정에서 문제가 하나씩 쌓이기 시작했습니다.

- 정규표현식이 늘어날수록 어디에 뭐가 있는지 파악이 어려워졌습니다
- 필드별로 에러메시지를 따로 관리하다 보니 코드가 산발적으로 흩어졌습니다
- 조건 하나가 바뀌면 연관된 정규표현식을 전부 찾아서 수정해야 했습니다

거기에 사용자 경험 개선 요구사항도 생겼습니다. 각 필드에 에러메시지를 개별 표시하고, 검증이 통과되지 않으면 제출 자체를 막아야 했습니다. 지금 구조로는 그걸 깔끔하게 구현하기가 어렵겠다는 생각이 들었습니다. 구조 자체를 바꿔야 할 때가 됐습니다.

## 라이브러리 선택

Vue 폼 유효성 검사 라이브러리로 가장 먼저 떠오른 건 **vee-validate**와 **vuelidate**였습니다.

두 라이브러리를 찾아봤는데, 둘 다 폼 상태 관리, 필드 바인딩, 에러 표시까지 통합으로 제공하는 구조였습니다. 기능이 많다는 건 그만큼 학습 비용도 있다는 뜻입니다. 우리 폼은 필드가 몇 개 없는 단순한 구조인데, 이 정도 폼에 통합 라이브러리를 도입하는 건 오버스펙이라고 판단했습니다.

고민하다가 방향을 바꿨습니다. **폼 관리는 지금처럼 Vue로 하되, 유효성 검사 로직만 Zod로 대체**하자는 것이었습니다. Zod는 폼 전용 라이브러리가 아니라 범용 스키마 검증 라이브러리입니다. 그래서 폼에 종속되지 않고 검증 로직만 깔끔하게 가져올 수 있었습니다.

## Zod로 유효성 검사하기

### 스키마 정의

`z.object()`로 폼 데이터의 검증 규칙을 한 곳에 선언합니다. 기존에는 각 필드 옆에 흩어져 있던 검증 조건들이 스키마 하나로 모입니다. 어떤 필드가 어떤 조건을 가지는지 한눈에 볼 수 있어서, 기획이 바뀌었을 때 어디를 수정해야 하는지 바로 찾을 수 있습니다.

```javascript
import { z } from "zod";

const formSchema = z.object({
  clubName: z.string().trim().min(1, "골프장명을 입력해주세요."),
  firstName: z.string().trim().min(1, "이름을 입력해주세요."),
  lastName: z.string().trim().min(1, "성을 입력해주세요."),
  contactNumber: z.union([z.number(), z.string()])
    .refine((value) => value > 0, "연락처를 입력해주세요."),
  email: z.string().min(1, "이메일을 입력해주세요.")
    .refine(emailCheck, "이메일 형식이 올바르지 않습니다."),
});
```

### contactNumber에서 막혔던 부분

`contactNumber` 필드에서 예상 못한 문제가 생겼습니다. `input type="number"`니까 당연히 숫자 타입일 거라고 생각했는데, Zod가 타입 오류를 냈습니다.

찾아보니 이유가 있었습니다. HTML 스펙에서 `input`의 `value`는 **항상 문자열**입니다. `type="number"`는 입력 UI를 숫자 전용으로 바꿔줄 뿐, 실제 값은 여전히 string입니다. Vue의 `v-model`도 `.number` 수정자를 붙이지 않으면 문자열 그대로 반응형 데이터에 들어갑니다.

그래서 `z.string()`으로만 정의하면 될 것 같았지만, 환경에 따라 숫자가 들어오는 경우도 있었습니다. `z.union()`으로 두 타입 모두 허용한 뒤, `refine()`으로 실제 값을 검사하는 방식으로 해결했습니다.

```javascript
contactNumber: z.union([z.number(), z.string()])
  .refine((value) => value > 0, "연락처를 입력해주세요."),
```

### 유효성 로직 분리

검증 함수를 따로 만들어서 제출 흐름과 분리했습니다.

```javascript
const isSubmitted = ref(false);
const errors = ref({});

const validateForm = () => {
  const result = formSchema.safeParse(formData);

  if (!result.success) {
    errors.value = result.error.format();
  } else {
    errors.value = {};
  }

  if (!isPrivacyChecked.value) {
    errors.value.isPrivacyChecked = "개인정보 동의를 체크해주세요.";
  }

  return result.success && isPrivacyChecked.value;
};

const submitForm = async () => {
  isSubmitted.value = true;
  if (!validateForm()) return;

  try {
    const res = await serviceInquiry(formData);
    if (res) router.push("/complete");
  } catch (error) {
    console.error(error);
  }
};
```

여기서 `parse` 대신 `safeParse`를 쓴 이유가 있습니다. `parse`는 검증에 실패하면 예외를 던집니다. 그러면 try-catch로 감싸야 하는데, 유효성 검사 실패는 예외 상황이 아니라 정상적인 흐름입니다. `safeParse`는 `{ success, data }` 또는 `{ success, error }` 형태의 객체를 반환하기 때문에, 예외 없이 결과만 보고 분기할 수 있습니다. 이게 훨씬 자연스럽습니다.

`result.error.format()`은 Zod의 에러 객체를 필드별로 정리된 구조로 변환합니다. 변환 후에는 `errors.clubName._errors[0]` 같은 방식으로 각 필드의 첫 번째 에러메시지에 접근할 수 있습니다.

개인정보 동의 체크박스는 Zod 스키마 바깥에 있어서 별도로 처리했습니다. 스키마 검증 결과와 함께 최종 반환값을 결정합니다.

```html
<p class="error-msg" v-if="errors.clubName">
  {{ errors.clubName?._errors[0] }}
</p>
```

### 실시간 유효성 검사

폼을 쓰다 보면 두 가지 UX 문제가 생깁니다. 첫째, 아무것도 입력 안 했는데 처음부터 에러가 뜨면 사용자가 당황합니다. 둘째, 제출했다가 실패한 뒤 수정하는데 에러가 바로바로 업데이트되지 않으면 불편합니다.

`isSubmitted` 플래그로 이 둘을 동시에 해결했습니다. 첫 제출 전에는 에러를 아예 표시하지 않고, 제출을 한 번 시도한 이후부터는 값이 바뀔 때마다 즉시 재검증합니다. 사용자 입장에서 가장 자연스러운 흐름입니다.

```javascript
watch(formData, () => {
  if (isSubmitted.value) {
    validateForm();
  }
}, { deep: true });
```

## 마무리

Zod를 쓰고 나서 가장 크게 달라진 건 **기획 변경이 무섭지 않아졌다**는 것입니다. 필드가 추가되면 스키마에 한 줄 추가하고, 조건이 바뀌면 해당 필드의 규칙만 고치면 됩니다. 기존에는 여기저기 흩어진 정규표현식을 찾아 헤매야 했습니다.

라이브러리 내부도 들여다봤는데, Zod가 하는 일은 결국 각 필드의 값을 정해진 조건으로 검사하고 실패 시 에러를 모으는 것입니다. 원리 자체는 단순합니다. 그래서 이 프로젝트 이후로는 폼이 충분히 단순하다면 직접 구현하는 쪽도 고려할 수 있겠다는 감이 생겼습니다. 도구를 쓰면서 그 안에서 무슨 일이 일어나는지 이해하게 됐다는 점에서, 단순히 라이브러리 도입 이상의 수확이었습니다.
