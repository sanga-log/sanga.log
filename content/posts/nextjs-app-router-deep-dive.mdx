---
title: "Next.js App Router 제대로 이해하기 — Server Component vs Client Component"
excerpt: "Next.js 13부터 도입된 App Router에서 Server Component와 Client Component를 언제 어떻게 나눠야 하는지, 실무에서 자주 하는 실수와 올바른 패턴을 정리했습니다. 데이터 패칭, 캐싱, 레이아웃 전략까지 다룹니다."
date: "2026-02-15"
category: "Next.js"
tags: ["Next.js", "App Router", "Server Component", "RSC"]
---

## App Router의 핵심: RSC

React Server Components(RSC)는 서버에서만 실행되는 컴포넌트입니다. 번들에 포함되지 않아 클라이언트 JS 사이즈를 줄일 수 있습니다.

## 언제 Server Component를 쓰나요?

- 데이터베이스, API를 직접 호출할 때
- 민감한 정보(API 키 등)를 다룰 때
- 대용량 dependency를 사용할 때 (마크다운 파서 등)
- `useState`, `useEffect`가 필요 없을 때

## 언제 Client Component를 쓰나요?

```tsx
'use client'; // 이 지시어가 필요한 경우:

// 1. 상태나 이벤트 핸들러가 필요할 때
// 2. useEffect, useRef 등의 훅을 쓸 때
// 3. 브라우저 전용 API (localStorage, window 등)
```

## 흔한 실수: 불필요한 'use client'

```tsx
// ❌ 잘못된 예: 전체 페이지를 Client Component로
'use client';
export default function Page() {
  const data = await fetchData(); // 이건 Server에서만!
  return <div>{data}</div>;
}

// ✅ 올바른 예: 상호작용이 필요한 부분만 분리
// app/page.tsx (Server Component)
export default async function Page() {
  const data = await fetchData();
  return (
    <div>
      <StaticContent data={data} />
      <InteractiveButton /> {/* Client Component */}
    </div>
  );
}
```

## 데이터 패칭 전략

```tsx
// 병렬 패칭
const [user, posts] = await Promise.all([
  getUser(userId),
  getPosts(userId),
]);

// 캐싱 설정
const res = await fetch('/api/data', {
  next: { revalidate: 3600 }, // 1시간 캐시
});
```

## 마치며

App Router의 핵심은 "서버에서 할 수 있는 건 서버에서"라는 원칙입니다. 처음엔 낯설지만 익숙해지면 성능과 DX 모두 향상됩니다.
